<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sudoku</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'batman-yellow': '#FFCC00',
                        'batman-gray': '#1E1E1E',
                        'batman-black': '#000000',
                    },
                    fontFamily: {
                        'batman': ['Impact', 'Arial Black', 'sans-serif'],
                    },
                    backgroundImage: {
                        'gotham-city': "url('data:image/svg+xml,%3Csvg width=\"100%25\" height=\"100%25\" xmlns=\"http://www.w3.org/2000/svg\"%3E%3Cdefs%3E%3Cpattern id=\"pattern\" width=\"100\" height=\"100\" patternUnits=\"userSpaceOnUse\"%3E%3Cpath d=\"M25,0 L50,50 L25,100 L0,50 Z M75,0 L100,50 L75,100 L50,50 Z\" fill=\"%23111111\" fill-opacity=\"0.2\"/%3E%3C/pattern%3E%3C/defs%3E%3Crect width=\"100%25\" height=\"100%25\" fill=\"url(%23pattern)\"/%3E%3C/svg%3E')",
                    }
                },
            },
            darkMode: 'class',
        }
    </script>
    <style>
        @keyframes batSignalGlow {
            0% { filter: drop-shadow(0 0 2px rgba(255, 204, 0, 0.5)); }
            50% { filter: drop-shadow(0 0 8px rgba(255, 204, 0, 0.8)); }
            100% { filter: drop-shadow(0 0 2px rgba(255, 204, 0, 0.5)); }
        }
        
        .bat-signal {
            animation: batSignalGlow 4s infinite;
        }
        
        .cell-selected {
            box-shadow: 0 0 0 2px #FFCC00;
        }
        
        .cell-conflict {
            color: #FF5252 !important;
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 0.8; }
            50% { opacity: 1; }
            100% { opacity: 0.8; }
        }
        
        /* Cell highlighting */
        .cell-highlighted {
            background-color: rgba(255, 204, 0, 0.07) !important;
        }
        
        .cell-same-number {
            background-color: rgba(0, 128, 255, 0.07) !important;
        }
        
        /* Number highlighting for placement */
        .cell-valid-placement {
            background-color: rgba(0, 200, 0, 0.07) !important;
        }
        
        .cell-invalid-placement {
            background-color: rgba(255, 0, 0, 0.03) !important;
        }
        
        /* Completed number styling */
        .number-btn.number-completed {
            background-color: #505050 !important;
            color: #909090 !important;
            cursor: not-allowed;
            opacity: 0.7;
        }
        
        /* Pencil marks */
        .pencil-marks {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            width: 100%;
            height: 100%;
            font-size: 0.6rem;
            line-height: 1;
        }
        
        .pencil-mark {
            display: flex;
            align-items: center;
            justify-content: center;
            color: #aaa;
        }
        
        .pencil-mark-conflict {
            color: #FF5252 !important;
            font-weight: bold;
        }
        
        /* Locked correct cell */
        .cell-correct {
            background-color: rgba(0, 200, 0, 0.05) !important;
            position: relative;
        }
        
        .cell-correct::after {
            content: "âœ“";
            position: absolute;
            top: 2px;
            right: 2px;
            font-size: 8px;
            color: #22C55E;
        }
        
        /* Completed region styles */
        .row-complete,
        .col-complete,
        .box-complete {
            background-color: rgba(0, 200, 0, 0.1) !important;
        }
        
        /* Make sure selection and conflict states take precedence */
        .cell.cell-selected,
        .cell.cell-conflict {
            z-index: 2;
        }
        
        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        
        /* Dropdown styles */
        .dropdown-content {
            display: none;
            position: absolute;
            z-index: 1;
        }
        
        .dropdown:hover .dropdown-content {
            display: block;
        }
        
        /* Save notification */
        #save-notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            display: none;
            z-index: 1000;
        }
        
        /* Responsive grid size */
        #sudoku-board {
            transition: transform 0.3s ease;
        }
        
        .zoom-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
        }
        
        .grid-size-display {
            width: 2.5rem;
            text-align: center;
        }
    </style>
</head>
<body class="min-h-screen bg-batman-gray text-white bg-gotham-city p-4 flex flex-col items-center">
    <!-- Batman App Container -->
    <div class="w-full max-w-md mx-auto bg-batman-black rounded-lg shadow-xl overflow-hidden">
        <!-- Header with Batman Logo -->
        <div class="relative bg-batman-yellow py-4 px-6 flex justify-center items-center">
            <div class="absolute left-4 bat-signal">
                <svg width="36" height="20" viewBox="0 0 36 20" fill="black">
                    <path d="M18,0 C12,0 7,3 4,8 C3,10 3,12 4,14 C7,19 12,22 18,22 C24,22 29,19 32,14 C33,12 33,10 32,8 C29,3 24,0 18,0 Z M18,4 C22,4 25,6 27,9 C28,11 28,13 27,15 C25,18 22,20 18,20 C14,20 11,18 9,15 C8,13 8,11 9,9 C11,6 14,4 18,4 Z M12,10 C12,10 13,14 18,14 C23,14 24,10 24,10 C24,10 21,12 18,12 C15,12 12,10 12,10 Z"/>
                </svg>
            </div>
            <h1 class="text-2xl sm:text-3xl font-batman tracking-wider text-batman-black">SUDOKU</h1>
            <div class="absolute right-4 flex space-x-2">
                <button id="settings-btn" class="bg-gray-900 text-white p-2 rounded-full hover:bg-gray-800 transition">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M11.49 3.17c-.38-1.56-2.6-1.56-2.98 0a1.532 1.532 0 01-2.286.948c-1.372-.836-2.942.734-2.106 2.106.54.886.061 2.042-.947 2.287-1.561.379-1.561 2.6 0 2.978a1.532 1.532 0 01.947 2.287c-.836 1.372.734 2.942 2.106 2.106a1.532 1.532 0 012.287.947c.379 1.561 2.6 1.561 2.978 0a1.533 1.533 0 012.287-.947c1.372.836 2.942-.734 2.106-2.106a1.533 1.533 0 01.947-2.287c1.561-.379 1.561-2.6 0-2.978a1.532 1.532 0 01-.947-2.287c.836-1.372-.734-2.942-2.106-2.106a1.532 1.532 0 01-2.287-.947zM10 13a3 3 0 100-6 3 3 0 000 6z" clip-rule="evenodd" />
                    </svg>
                </button>
                <button id="stats-btn" class="bg-gray-900 text-white p-2 rounded-full hover:bg-gray-800 transition">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                        <path d="M2 11a1 1 0 011-1h2a1 1 0 011 1v5a1 1 0 01-1 1H3a1 1 0 01-1-1v-5zM8 7a1 1 0 011-1h2a1 1 0 011 1v9a1 1 0 01-1 1H9a1 1 0 01-1-1V7zM14 4a1 1 0 011-1h2a1 1 0 011 1v12a1 1 0 01-1 1h-2a1 1 0 01-1-1V4z" />
                    </svg>
                </button>
            </div>
        </div>
        
        <!-- Game Status Message -->
        <div id="status" class="bg-gray-800 text-center py-2 font-bold text-batman-yellow">
            Ready to solve the city's puzzles?
        </div>
        
        <!-- Grid Size Controls -->
        <div class="bg-gray-900 py-2 px-4 flex justify-center">
            <div class="zoom-controls">
                <button id="zoom-out" class="bg-gray-700 rounded-full w-7 h-7 flex items-center justify-center hover:bg-gray-600 transition">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd" />
                    </svg>
                </button>
                <span id="grid-size-display" class="grid-size-display">100%</span>
                <button id="zoom-in" class="bg-gray-700 rounded-full w-7 h-7 flex items-center justify-center hover:bg-gray-600 transition">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z" clip-rule="evenodd" />
                    </svg>
                </button>
            </div>
        </div>
        
        <!-- Sudoku Grid -->
        <div class="p-3 sm:p-4 flex justify-center">
            <div id="sudoku-board" class="grid grid-cols-9 gap-0.5 bg-gray-800 p-1 rounded">
                <!-- Grid cells will be generated with JavaScript -->
            </div>
        </div>
        
        <!-- Game Controls -->
        <div class="p-3 sm:p-4 bg-gray-900">
            <!-- Input Modes -->
            <div class="flex justify-center mb-2">
                <div class="flex bg-gray-700 p-1 rounded">
                    <button id="normal-mode-btn" class="px-3 py-1 rounded bg-batman-yellow text-batman-black font-bold text-sm">Normal</button>
                    <button id="pencil-mode-btn" class="px-3 py-1 rounded text-gray-300 font-bold text-sm">Pencil Mark</button>
                </div>
            </div>
            
            <!-- Number Buttons -->
            <div class="grid grid-cols-5 gap-2">
                <button class="number-btn col-span-1 bg-batman-yellow text-batman-black font-bold text-xl h-10 rounded shadow hover:bg-yellow-400 transition" data-num="1">1</button>
                <button class="number-btn col-span-1 bg-batman-yellow text-batman-black font-bold text-xl h-10 rounded shadow hover:bg-yellow-400 transition" data-num="2">2</button>
                <button class="number-btn col-span-1 bg-batman-yellow text-batman-black font-bold text-xl h-10 rounded shadow hover:bg-yellow-400 transition" data-num="3">3</button>
                <button class="number-btn col-span-1 bg-batman-yellow text-batman-black font-bold text-xl h-10 rounded shadow hover:bg-yellow-400 transition" data-num="4">4</button>
                <button class="number-btn col-span-1 bg-batman-yellow text-batman-black font-bold text-xl h-10 rounded shadow hover:bg-yellow-400 transition" data-num="5">5</button>
                <button class="number-btn col-span-1 bg-batman-yellow text-batman-black font-bold text-xl h-10 rounded shadow hover:bg-yellow-400 transition" data-num="6">6</button>
                <button class="number-btn col-span-1 bg-batman-yellow text-batman-black font-bold text-xl h-10 rounded shadow hover:bg-yellow-400 transition" data-num="7">7</button>
                <button class="number-btn col-span-1 bg-batman-yellow text-batman-black font-bold text-xl h-10 rounded shadow hover:bg-yellow-400 transition" data-num="8">8</button>
                <button class="number-btn col-span-1 bg-batman-yellow text-batman-black font-bold text-xl h-10 rounded shadow hover:bg-yellow-400 transition" data-num="9">9</button>
                <button id="erase-btn" class="col-span-1 bg-gray-700 text-white font-bold h-10 rounded shadow hover:bg-gray-600 transition">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mx-auto" viewBox="0 0 20 20" fill="currentColor">
                        <path fill-rule="evenodd" d="M6.707 4.879A3 3 0 018.828 4H15a3 3 0 013 3v9a3 3 0 01-3 3H8.828a3 3 0 01-2.12-.879l-4.415-4.414a1 1 0 010-1.414l4.414-4.414zm4 2.414a1 1 0 00-1.414 1.414L10.586 10l-1.293 1.293a1 1 0 101.414 1.414L12 11.414l1.293 1.293a1 1 0 001.414-1.414L13.414 10l1.293-1.293a1 1 0 00-1.414-1.414L12 8.586l-1.293-1.293z" clip-rule="evenodd" />
                    </svg>
                </button>
            </div>
        </div>
        
        <!-- Action Buttons -->
        <div class="p-3 sm:p-4 bg-gray-800 flex flex-wrap justify-between gap-2">
            <button id="new-game-btn" class="bg-batman-yellow text-batman-black px-4 py-2 rounded font-batman tracking-wide shadow hover:bg-yellow-400 transition">
                NEW PUZZLE
            </button>
            <button id="hint-btn" class="bg-gray-600 text-white px-4 py-2 rounded font-batman tracking-wide shadow hover:bg-gray-500 transition">
                HINT
            </button>
            <button id="check-btn" class="bg-gray-900 text-white px-4 py-2 rounded font-batman tracking-wide shadow hover:bg-gray-800 transition">
                CHECK
            </button>
        </div>
        
        <!-- Share/Import Buttons -->
        <div class="p-3 sm:p-4 bg-gray-900 flex flex-wrap justify-between gap-2">
            <button id="saved-games-btn" class="bg-purple-600 text-white px-4 py-2 rounded font-batman tracking-wide shadow hover:bg-purple-700 transition flex items-center justify-center gap-1">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 3v4M3 5h4M6 17v4m-2-2h4m5-16l2.286 6.857L21 12l-5.714 2.143L13 21l-2.286-6.857L5 12l5.714-2.143L13 3z" />
                </svg>
                SAVED GAMES
            </button>
            <button id="share-btn" class="bg-blue-600 text-white px-4 py-2 rounded font-batman tracking-wide shadow hover:bg-blue-700 transition flex items-center justify-center gap-1">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.684 13.342C8.886 12.938 9 12.482 9 12c0-.482-.114-.938-.316-1.342m0 2.684a3 3 0 110-2.684m0 2.684l6.632 3.316m-6.632-6l6.632-3.316m0 0a3 3 0 105.367-2.684 3 3 0 00-5.367 2.684zm0 9.316a3 3 0 105.368 2.684 3 3 0 00-5.368-2.684z" />
                </svg>
                SHARE PUZZLE
            </button>
        </div>
        
        <!-- Footer -->
        <div class="text-center py-2 text-xs text-gray-400 bg-gray-900">
            Developed by CygRyu
        </div>
    </div>

    <!-- Share Modal -->
    <div id="share-modal" class="modal">
        <div class="bg-gray-800 p-6 rounded-lg shadow-lg max-w-md w-full">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-lg font-bold text-white">Share Puzzle</h3>
                <button id="close-share-modal" class="text-gray-400 hover:text-gray-200">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                    </svg>
                </button>
            </div>
            <p class="mb-4 text-gray-300">Copy this code to share the current puzzle:</p>
            <div class="relative">
                <input id="share-code" type="text" readonly class="w-full p-2 border rounded bg-gray-700 text-white border-gray-600 text-sm font-mono" />
                <button id="copy-btn" class="absolute right-2 top-2 text-gray-400 hover:text-gray-200">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
                    </svg>
                </button>
            </div>
            <p id="copy-message" class="mt-2 text-green-600 hidden">Copied to clipboard!</p>
        </div>
    </div>

    <!-- Import Modal -->
    <div id="import-modal" class="modal">
        <div class="bg-gray-800 p-6 rounded-lg shadow-lg max-w-md w-full">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-lg font-bold text-white">Import Puzzle</h3>
                <button id="close-import-modal" class="text-gray-400 hover:text-gray-200">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                    </svg>
                </button>
            </div>
            <p class="mb-4 text-gray-300">Paste the puzzle code below:</p>
            <input id="import-code" type="text" class="w-full p-2 border rounded bg-gray-700 text-white border-gray-600 mb-4 text-base" placeholder="Paste puzzle code here" />
            <div class="flex justify-end">
                <button id="import-submit-btn" class="bg-green-600 text-white px-4 py-2 rounded shadow hover:bg-green-700 transition">Import</button>
            </div>
            <p id="import-error" class="mt-2 text-red-600 hidden">Invalid puzzle code. Please try again.</p>
        </div>
    </div>

    <!-- Statistics Modal -->
    <div id="stats-modal" class="modal">
        <div class="bg-gray-800 p-6 rounded-lg shadow-lg max-w-md w-full">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-lg font-bold text-white">Detective Records</h3>
                <button id="close-stats-modal" class="text-gray-400 hover:text-gray-200">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                    </svg>
                </button>
            </div>
            
            <!-- Player Name Input -->
            <div class="mb-4">
                <label for="player-name" class="block text-sm font-medium text-gray-300 mb-1">Detective Name</label>
                <input type="text" id="player-name" class="w-full p-2 border rounded bg-gray-700 text-white border-gray-600 text-base" placeholder="Enter your detective name" />
            </div>
            
            <!-- Statistics Panel -->
            <div class="mb-6">
                <h4 class="font-bold mb-2 text-batman-yellow">Statistics</h4>
                <div class="grid grid-cols-2 gap-4">
                    <div class="bg-gray-700 p-3 rounded">
                        <div class="text-sm text-gray-400">Puzzles Solved</div>
                        <div id="puzzles-solved" class="text-xl font-bold text-white">0</div>
                    </div>
                    <div class="bg-gray-700 p-3 rounded">
                        <div class="text-sm text-gray-400">No Hint Solves</div>
                        <div id="no-hint-solves" class="text-xl font-bold text-white">0</div>
                    </div>
                </div>
            </div>
            
            <div class="flex justify-end">
                <button id="save-stats-btn" class="bg-batman-yellow text-batman-black px-4 py-2 rounded shadow hover:bg-yellow-400 transition">Save</button>
            </div>
        </div>
    </div>
    
    <!-- Settings Modal -->
    <div id="settings-modal" class="modal">
        <div class="bg-gray-800 p-6 rounded-lg shadow-lg max-w-md w-full">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-lg font-bold text-white">Game Settings</h3>
                <button id="close-settings-modal" class="text-gray-400 hover:text-gray-200">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                    </svg>
                </button>
            </div>
            
            <!-- Gameplay Settings (New Section) -->
            <div class="mb-4">
                <h4 class="font-bold mb-2 text-batman-yellow">Gameplay Settings</h4>
                <div class="space-y-2">
                    <label class="flex items-center cursor-pointer text-sm">
                        <input type="checkbox" id="highlight-row-col-box" class="mr-2 h-4 w-4" checked>
                        <span>Highlight Row/Col/Box</span>
                    </label>
                    <label class="flex items-center cursor-pointer text-sm">
                        <input type="checkbox" id="highlight-same-numbers" class="mr-2 h-4 w-4" checked>
                        <span>Highlight Same Numbers</span>
                    </label>
                </div>
            </div>
            
            <hr class="border-gray-600 my-4">
            
            <!-- Auto-save Settings -->
            <div class="mb-4">
                <h4 class="font-bold mb-2 text-batman-yellow">Save Settings</h4>
                <label class="flex items-center cursor-pointer text-sm mb-2">
                    <input type="checkbox" id="auto-save-toggle" class="mr-2 h-4 w-4" checked>
                    <span>Auto-save game every 30 seconds</span>
                </label>
                
                <div class="flex space-x-2 mt-2">
                    <button id="manual-save-btn" class="bg-green-600 text-white px-3 py-1 rounded shadow hover:bg-green-700 transition text-sm">
                        Save Game Now
                    </button>
                    <button id="export-game-btn" class="bg-blue-600 text-white px-3 py-1 rounded shadow hover:bg-blue-700 transition text-sm">
                        Export Game Data
                    </button>
                    <button id="import-game-btn" class="bg-purple-600 text-white px-3 py-1 rounded shadow hover:bg-purple-700 transition text-sm">
                        Import Game Data
                    </button>
                </div>
            </div>
            
            <hr class="border-gray-600 my-4">
            
            <!-- Data Management -->
            <div class="mb-4">
                <h4 class="font-bold mb-2 text-batman-yellow">Data Management</h4>
                <div class="flex space-x-2">
                    <button id="clear-data-btn" class="bg-red-600 text-white px-3 py-1 rounded shadow hover:bg-red-700 transition text-sm">
                        Clear All Data
                    </button>
                </div>
                <p class="text-xs text-gray-400 mt-1">This will delete all saved games and statistics</p>
            </div>
        </div>
    </div>
    
    <!-- Saved Games Modal -->
    <div id="saved-games-modal" class="modal">
        <div class="bg-gray-800 p-6 rounded-lg shadow-lg max-w-md w-full">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-lg font-bold text-white">Saved Games</h3>
                <button id="close-saved-games-modal" class="text-gray-400 hover:text-gray-200">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                    </svg>
                </button>
            </div>
            
            <div class="mb-4">
                <div id="saved-games-container" class="space-y-2 max-h-60 overflow-y-auto">
                    <!-- Saved games will be added here dynamically -->
                    <p id="no-saved-games" class="text-center text-gray-400 py-4">No saved games found</p>
                </div>
            </div>
            
            <div class="flex justify-between mt-4">
                <input type="text" id="save-game-name" class="flex-1 p-2 border rounded-l bg-gray-700 text-white border-gray-600 text-base" placeholder="Name your save (optional)" />
                <button id="save-game-btn" class="bg-green-600 text-white px-3 py-2 rounded-r shadow hover:bg-green-700 transition">Save Current Game</button>
            </div>
        </div>
    </div>
    
    <!-- New Game Confirmation Modal -->
    <div id="new-game-confirm-modal" class="modal">
        <div class="bg-gray-800 p-6 rounded-lg shadow-lg max-w-md w-full">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-lg font-bold text-white">Start New Puzzle?</h3>
                <button id="close-new-game-modal" class="text-gray-400 hover:text-gray-200">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                    </svg>
                </button>
            </div>
            <p class="mb-6 text-gray-300">Starting a new puzzle will lose your current progress. Are you sure you want to continue?</p>
            <div class="flex justify-end space-x-3">
                <button id="cancel-new-game-btn" class="bg-gray-500 text-white px-4 py-2 rounded shadow hover:bg-gray-600 transition">Cancel</button>
                <button id="confirm-new-game-btn" class="bg-batman-yellow text-batman-black px-4 py-2 rounded shadow hover:bg-yellow-400 transition">Start New Puzzle</button>
            </div>
        </div>
    </div>
    
    <!-- Hint Confirmation Modal -->
    <div id="hint-confirm-modal" class="modal">
        <div class="bg-gray-800 p-6 rounded-lg shadow-lg max-w-md w-full">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-lg font-bold text-white">Use a Hint?</h3>
                <button id="close-hint-modal" class="text-gray-400 hover:text-gray-200">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                    </svg>
                </button>
            </div>
            <p class="mb-6 text-gray-300">You have <span id="hints-remaining-display" class="font-bold text-batman-yellow"></span> hints left. Do you want to use one now?</p>
            <div class="flex justify-end space-x-3">
                <button id="cancel-hint-btn" class="bg-gray-500 text-white px-4 py-2 rounded shadow hover:bg-gray-600 transition">Cancel</button>
                <button id="confirm-hint-btn" class="bg-batman-yellow text-batman-black px-4 py-2 rounded shadow hover:bg-yellow-400 transition">Use Hint</button>
            </div>
        </div>
    </div>
    
    <!-- Save Notification -->
    <div id="save-notification" class="bg-gray-800 text-white px-4 py-2 rounded shadow-lg">
        Game auto-saved
    </div>

    <script>
        // Game state variables
        let board = Array(9).fill().map(() => Array(9).fill(0));
        let solution = Array(9).fill().map(() => Array(9).fill(0));
        let initialCells = Array(9).fill().map(() => Array(9).fill(false));
        let selectedCell = null;
        let hintsRemaining = 3;
        
        // New variables for enhanced features
        let pencilMarks = Array(9).fill().map(() => Array(9).fill().map(() => Array(9).fill(false)));
        let isPencilMode = false;
        let highlightRowColBox = true;
        let highlightSameNumbers = true;
        let gridScale = 100; // Default grid scale in percentage
        let correctCells = Array(9).fill().map(() => Array(9).fill(false)); // Track cells with correct values
        let initialBoard = null; // Store initial board for restart feature
        let completedNumbers = Array(10).fill(false); // Track completed numbers (index 0 unused)
        let isNumberHighlightMode = false; // Track if we're in number placement highlight mode
        let highlightedNumber = null; // The currently highlighted number for placement
        
        // Auto-save variables
        let autoSaveEnabled = true;
        let autoSaveInterval = null;
        
        // Generation feedback variables
        let puzzleGenerationTime = 0;
        let cluesCount = 0;
        
        // Statistics 
        let stats = {
            puzzlesSolved: 0,
            noHintSolves: 0,
            currentGameUsedHint: false,
            playerName: 'Detective'
        };
        
        // Initialize the game board
        function initializeBoard() {
            const sudokuBoard = document.getElementById('sudoku-board');
            sudokuBoard.innerHTML = '';
            
            for (let row = 0; row < 9; row++) {
                for (let col = 0; col < 9; col++) {
                    const cell = document.createElement('div');
                    cell.classList.add(
                        'cell', 
                        'w-8', 'h-8', 'sm:w-9', 'sm:h-9', 
                        'flex', 'items-center', 'justify-center', 
                        'bg-gray-700', 
                        'text-lg', 'font-bold', 'cursor-pointer',
                        'transition', 'duration-150'
                    );
                    
                    // Add box borders
                    if (row % 3 === 0 && row !== 0) {
                        cell.classList.add('border-t-2', 'border-t-batman-yellow');
                    }
                    if (col % 3 === 0 && col !== 0) {
                        cell.classList.add('border-l-2', 'border-l-batman-yellow');
                    }
                    
                    cell.dataset.row = row;
                    cell.dataset.col = col;
                    
                    // Set the box data attribute for region completion tracking
                    const boxIndex = Math.floor(row / 3) * 3 + Math.floor(col / 3);
                    cell.dataset.box = boxIndex;
                    
                    cell.addEventListener('click', () => selectCell(cell));
                    
                    sudokuBoard.appendChild(cell);
                }
            }
        }
        
        // Select a cell
        function selectCell(cell) {
            // Exit number highlight mode when a cell is selected
            if (isNumberHighlightMode) {
                clearAllHighlights();
                isNumberHighlightMode = false;
                highlightedNumber = null;
            }
            
            // Clear previous selection
            if (selectedCell) {
                selectedCell.classList.remove('cell-selected', 'bg-gray-600');
            }
            
            // Clear all highlights
            clearHighlights();
            
            // Set new selection
            selectedCell = cell;
            cell.classList.add('cell-selected', 'bg-gray-600');
            
            // Apply highlighting based on settings
            const row = parseInt(cell.dataset.row);
            const col = parseInt(cell.dataset.col);
            
            if (highlightRowColBox) {
                highlightRelatedCells(row, col);
            }
            
            if (highlightSameNumbers && board[row][col] !== 0) {
                highlightSameNumber(board[row][col]);
            }
        }
        
        // Clear all cell highlights
        function clearHighlights() {
            document.querySelectorAll('.cell-highlighted, .cell-same-number').forEach(cell => {
                cell.classList.remove('cell-highlighted', 'cell-same-number');
            });
        }
        
        // Clear all highlights including placement related ones
        function clearAllHighlights() {
            document.querySelectorAll('.cell-highlighted, .cell-same-number, .cell-valid-placement, .cell-invalid-placement').forEach(cell => {
                cell.classList.remove('cell-highlighted', 'cell-same-number', 'cell-valid-placement', 'cell-invalid-placement');
            });
        }
        
        // Highlight cells in the same row, column, and box
        function highlightRelatedCells(row, col) {
            // Highlight row
            for (let c = 0; c < 9; c++) {
                if (c !== col) {
                    const cell = document.querySelector(`.cell[data-row="${row}"][data-col="${c}"]`);
                    cell.classList.add('cell-highlighted');
                }
            }
            
            // Highlight column
            for (let r = 0; r < 9; r++) {
                if (r !== row) {
                    const cell = document.querySelector(`.cell[data-row="${r}"][data-col="${col}"]`);
                    cell.classList.add('cell-highlighted');
                }
            }
            
            // Highlight box
            const boxRowStart = Math.floor(row / 3) * 3;
            const boxColStart = Math.floor(col / 3) * 3;
            
            for (let r = boxRowStart; r < boxRowStart + 3; r++) {
                for (let c = boxColStart; c < boxColStart + 3; c++) {
                    if (r !== row || c !== col) {
                        const cell = document.querySelector(`.cell[data-row="${r}"][data-col="${c}"]`);
                        cell.classList.add('cell-highlighted');
                    }
                }
            }
        }
        
        // Highlight cells with the same number
        function highlightSameNumber(num) {
            for (let row = 0; row < 9; row++) {
                for (let col = 0; col < 9; col++) {
                    if (board[row][col] === num) {
                        const cell = document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
                        cell.classList.add('cell-same-number');
                    }
                }
            }
        }
        
        // Highlight valid and invalid placement options for a number
        function highlightPlacementOptions(num) {
            clearAllHighlights();
            
            // First highlight existing instances of the number
            for (let row = 0; row < 9; row++) {
                for (let col = 0; col < 9; col++) {
                    if (board[row][col] === num) {
                        const cell = document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
                        cell.classList.add('cell-same-number');
                        
                        // Also mark all cells in same row, column, and box as invalid placement
                        markInvalidPlacements(row, col);
                    }
                }
            }
            
            // Mark remaining empty cells as either valid or invalid
            for (let row = 0; row < 9; row++) {
                for (let col = 0; col < 9; col++) {
                    if (board[row][col] === 0) {
                        const cell = document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
                        
                        // Skip cells that are already marked as invalid
                        if (cell.classList.contains('cell-invalid-placement')) {
                            continue;
                        }
                        
                        // Check if this would be a valid placement
                        if (isValidPlace(board, row, col, num)) {
                            cell.classList.add('cell-valid-placement');
                        } else {
                            cell.classList.add('cell-invalid-placement');
                        }
                    }
                }
            }
        }
        
        // Mark cells in same row, column, and box as invalid for placement
        function markInvalidPlacements(row, col) {
            // Mark row cells as invalid
            for (let c = 0; c < 9; c++) {
                if (board[row][c] === 0) {
                    const cell = document.querySelector(`.cell[data-row="${row}"][data-col="${c}"]`);
                    cell.classList.add('cell-invalid-placement');
                }
            }
            
            // Mark column cells as invalid
            for (let r = 0; r < 9; r++) {
                if (board[r][col] === 0) {
                    const cell = document.querySelector(`.cell[data-row="${r}"][data-col="${col}"]`);
                    cell.classList.add('cell-invalid-placement');
                }
            }
            
            // Mark box cells as invalid
            const boxRowStart = Math.floor(row / 3) * 3;
            const boxColStart = Math.floor(col / 3) * 3;
            
            for (let r = boxRowStart; r < boxRowStart + 3; r++) {
                for (let c = boxColStart; c < boxColStart + 3; c++) {
                    if (board[r][c] === 0) {
                        const cell = document.querySelector(`.cell[data-row="${r}"][data-col="${c}"]`);
                        cell.classList.add('cell-invalid-placement');
                    }
                }
            }
        }
        
        // Update the board display
        function updateBoard() {
            const cells = document.querySelectorAll('.cell');
            
            cells.forEach(cell => {
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                const value = board[row][col];
                
                // Reset cell content and classes
                cell.innerHTML = '';
                cell.classList.remove(
                    'text-white', 'text-batman-yellow', 'font-bold', 'cell-conflict',
                    'cell-correct'
                );
                
                // Add correct cell class if applicable
                if (correctCells[row][col]) {
                    cell.classList.add('cell-correct');
                }
                
                if (value !== 0) {
                    // Display the value
                    cell.textContent = value;
                    
                    if (initialCells[row][col]) {
                        // Initial cells
                        cell.classList.add('text-batman-yellow', 'font-bold');
                    } else {
                        // User entered cells
                        cell.classList.add('text-white');
                    }
                } else {
                    // Check if there are pencil marks for this cell
                    const cellPencilMarks = pencilMarks[row][col];
                    if (cellPencilMarks.some(mark => mark)) {
                        // Create pencil marks grid
                        const marksContainer = document.createElement('div');
                        marksContainer.classList.add('pencil-marks');
                        
                        for (let num = 1; num <= 9; num++) {
                            const markSpan = document.createElement('div');
                            markSpan.classList.add('pencil-mark');
                            
                            if (cellPencilMarks[num-1]) {
                                markSpan.textContent = num;
                                
                                // Check if this pencil mark would create a conflict
                                if (wouldCreateConflict(row, col, num)) {
                                    markSpan.classList.add('pencil-mark-conflict');
                                }
                            }
                            
                            marksContainer.appendChild(markSpan);
                        }
                        
                        cell.appendChild(marksContainer);
                    }
                }
            });
            
            // Check for conflicts after updating values
            checkForConflicts();
            
            // Check for completed regions
            checkCompletedRegions();
            
            // Check for correct cells
            checkCorrectCells();
            
            // Check for completed numbers
            checkCompletedNumbers();
            
            // Update number button status
            updateNumberButtons();
        }
        
        // Check if a number would create a conflict in row, column, or box
        function wouldCreateConflict(row, col, num) {
            // Check row
            for (let c = 0; c < 9; c++) {
                if (c !== col && board[row][c] === num) {
                    return true;
                }
            }
            
            // Check column
            for (let r = 0; r < 9; r++) {
                if (r !== row && board[r][col] === num) {
                    return true;
                }
            }
            
            // Check box
            const boxRowStart = Math.floor(row / 3) * 3;
            const boxColStart = Math.floor(col / 3) * 3;
            
            for (let r = boxRowStart; r < boxRowStart + 3; r++) {
                for (let c = boxColStart; c < boxColStart + 3; c++) {
                    if ((r !== row || c !== col) && board[r][c] === num) {
                        return true;
                    }
                }
            }
            
            return false;
        }
        
        // Check for correct cells and mark them
        function checkCorrectCells() {
            for (let row = 0; row < 9; row++) {
                for (let col = 0; col < 9; col++) {
                    // Only check user-entered (non-initial) cells with values
                    if (!initialCells[row][col] && board[row][col] !== 0) {
                        // If cell value matches solution, mark it as correct
                        correctCells[row][col] = (board[row][col] === solution[row][col]);
                    }
                }
            }
        }
        
        // Check for completed numbers (all 9 instances placed correctly)
        function checkCompletedNumbers() {
            // Reset completion tracking
            completedNumbers = Array(10).fill(false);
            
            // Count each number's correctly placed instances
            for (let num = 1; num <= 9; num++) {
                let correctCount = 0;
                
                for (let row = 0; row < 9; row++) {
                    for (let col = 0; col < 9; col++) {
                        if (board[row][col] === num && (initialCells[row][col] || correctCells[row][col])) {
                            correctCount++;
                        }
                    }
                }
                
                // If all 9 instances are placed correctly, mark as completed
                if (correctCount === 9) {
                    completedNumbers[num] = true;
                }
            }
        }
        
        // Update number buttons based on completion status
        function updateNumberButtons() {
            const numberButtons = document.querySelectorAll('.number-btn');
            
            numberButtons.forEach(button => {
                const num = parseInt(button.dataset.num);
                
                // Remove completion class if it's not completed
                if (!completedNumbers[num]) {
                    button.classList.remove('number-completed');
                } else {
                    // Add completion class if it's completed
                    button.classList.add('number-completed');
                }
            });
        }
        
        // Check for conflicts in rows, columns and boxes
        function checkForConflicts() {
            // Clear all conflicts first
            document.querySelectorAll('.cell').forEach(cell => {
                cell.classList.remove('cell-conflict');
            });
            
            // Check rows
            for (let row = 0; row < 9; row++) {
                const rowValues = {};
                for (let col = 0; col < 9; col++) {
                    const value = board[row][col];
                    if (value !== 0) {
                        if (rowValues[value]) {
                            // Conflict found in row
                            for (let c = 0; c < 9; c++) {
                                if (board[row][c] === value) {
                                    const cell = document.querySelector(`.cell[data-row="${row}"][data-col="${c}"]`);
                                    cell.classList.add('cell-conflict');
                                }
                            }
                        }
                        rowValues[value] = true;
                    }
                }
            }
            
            // Check columns
            for (let col = 0; col < 9; col++) {
                const colValues = {};
                for (let row = 0; row < 9; row++) {
                    const value = board[row][col];
                    if (value !== 0) {
                        if (colValues[value]) {
                            // Conflict found in column
                            for (let r = 0; r < 9; r++) {
                                if (board[r][col] === value) {
                                    const cell = document.querySelector(`.cell[data-row="${r}"][data-col="${col}"]`);
                                    cell.classList.add('cell-conflict');
                                }
                            }
                        }
                        colValues[value] = true;
                    }
                }
            }
            
            // Check 3x3 boxes
            for (let boxRow = 0; boxRow < 3; boxRow++) {
                for (let boxCol = 0; boxCol < 3; boxCol++) {
                    const boxValues = {};
                    for (let r = 0; r < 3; r++) {
                        for (let c = 0; c < 3; c++) {
                            const row = boxRow * 3 + r;
                            const col = boxCol * 3 + c;
                            const value = board[row][col];
                            
                            if (value !== 0) {
                                if (boxValues[value]) {
                                    // Conflict found in box
                                    for (let rr = 0; rr < 3; rr++) {
                                        for (let cc = 0; cc < 3; cc++) {
                                            const conflictRow = boxRow * 3 + rr;
                                            const conflictCol = boxCol * 3 + cc;
                                            if (board[conflictRow][conflictCol] === value) {
                                                const cell = document.querySelector(`.cell[data-row="${conflictRow}"][data-col="${conflictCol}"]`);
                                                cell.classList.add('cell-conflict');
                                            }
                                        }
                                    }
                                }
                                boxValues[value] = true;
                            }
                        }
                    }
                }
            }
        }
        
        // Check for completed regions (rows, columns, boxes)
        function checkCompletedRegions() {
            // Remove all completion classes
            document.querySelectorAll('.cell').forEach(cell => {
                cell.classList.remove('row-complete', 'col-complete', 'box-complete');
            });
            
            // Check rows
            for (let row = 0; row < 9; row++) {
                // Check if row is complete and correct
                let isRowComplete = true;
                let hasConflict = false;
                
                // Check if all cells are filled
                for (let col = 0; col < 9; col++) {
                    if (board[row][col] === 0) {
                        isRowComplete = false;
                        break;
                    }
                }
                
                // Check if row has no conflicts and matches solution
                if (isRowComplete) {
                    for (let col = 0; col < 9; col++) {
                        if (board[row][col] !== solution[row][col]) {
                            hasConflict = true;
                            break;
                        }
                    }
                }
                
                // If row is complete and correct, highlight it
                if (isRowComplete && !hasConflict) {
                    for (let col = 0; col < 9; col++) {
                        const cell = document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
                        cell.classList.add('row-complete');
                    }
                }
            }
            
            // Check columns
            for (let col = 0; col < 9; col++) {
                // Check if column is complete and correct
                let isColComplete = true;
                let hasConflict = false;
                
                // Check if all cells are filled
                for (let row = 0; row < 9; row++) {
                    if (board[row][col] === 0) {
                        isColComplete = false;
                        break;
                    }
                }
                
                // Check if column has no conflicts and matches solution
                if (isColComplete) {
                    for (let row = 0; row < 9; row++) {
                        if (board[row][col] !== solution[row][col]) {
                            hasConflict = true;
                            break;
                        }
                    }
                }
                
                // If column is complete and correct, highlight it
                if (isColComplete && !hasConflict) {
                    for (let row = 0; row < 9; row++) {
                        const cell = document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
                        cell.classList.add('col-complete');
                    }
                }
            }
            
            // Check boxes
            for (let boxIndex = 0; boxIndex < 9; boxIndex++) {
                const boxRow = Math.floor(boxIndex / 3) * 3;
                const boxCol = (boxIndex % 3) * 3;
                
                // Check if box is complete and correct
                let isBoxComplete = true;
                let hasConflict = false;
                
                // Check if all cells are filled
                for (let r = 0; r < 3; r++) {
                    for (let c = 0; c < 3; c++) {
                        const row = boxRow + r;
                        const col = boxCol + c;
                        
                        if (board[row][col] === 0) {
                            isBoxComplete = false;
                            break;
                        }
                    }
                    if (!isBoxComplete) break;
                }
                
                // Check if box has no conflicts and matches solution
                if (isBoxComplete) {
                    for (let r = 0; r < 3; r++) {
                        for (let c = 0; c < 3; c++) {
                            const row = boxRow + r;
                            const col = boxCol + c;
                            
                            if (board[row][col] !== solution[row][col]) {
                                hasConflict = true;
                                break;
                            }
                        }
                        if (hasConflict) break;
                    }
                }
                
                // If box is complete and correct, highlight it
                if (isBoxComplete && !hasConflict) {
                    for (let r = 0; r < 3; r++) {
                        for (let c = 0; c < 3; c++) {
                            const row = boxRow + r;
                            const col = boxCol + c;
                            const cell = document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
                            cell.classList.add('box-complete');
                        }
                    }
                }
            }
        }
        
        // Generate a complete, solved Sudoku board
        function generateSolution() {
            // Initialize empty solution
            solution = Array(9).fill().map(() => Array(9).fill(0));
            
            // Fill the diagonal boxes first (these can be filled independently)
            for (let box = 0; box < 9; box += 3) {
                fillBox(box, box);
            }
            
            // Fill the rest of the board
            solveSudoku();
            
            return solution;
        }
        
        // Fill a 3x3 box with random numbers
        function fillBox(startRow, startCol) {
            const nums = shuffleArray([1, 2, 3, 4, 5, 6, 7, 8, 9]);
            let index = 0;
            
            for (let row = 0; row < 3; row++) {
                for (let col = 0; col < 3; col++) {
                    solution[startRow + row][startCol + col] = nums[index++];
                }
            }
        }
        
        // Solve the Sudoku puzzle using backtracking
        function solveSudoku() {
            for (let row = 0; row < 9; row++) {
                for (let col = 0; col < 9; col++) {
                    // Skip filled cells
                    if (solution[row][col] !== 0) continue;
                    
                    // Try each number
                    for (let num = 1; num <= 9; num++) {
                        if (isValid(solution, row, col, num)) {
                            solution[row][col] = num;
                            
                            // If we can solve the rest of the puzzle, we're done
                            if (solveSudoku()) {
                                return true;
                            }
                            
                            // Otherwise, backtrack
                            solution[row][col] = 0;
                        }
                    }
                    
                    // If we get here, no number worked, so we need to backtrack
                    return false;
                }
            }
            
            // If we've filled all cells, we've solved the puzzle
            return true;
        }
        
        // Check if placing a number at a position is valid
        function isValid(grid, row, col, num) {
            // Check row
            for (let x = 0; x < 9; x++) {
                if (grid[row][x] === num) return false;
            }
            
            // Check column
            for (let x = 0; x < 9; x++) {
                if (grid[x][col] === num) return false;
            }
            
            // Check 3x3 box
            const boxRow = Math.floor(row / 3) * 3;
            const boxCol = Math.floor(col / 3) * 3;
            
            for (let r = 0; r < 3; r++) {
                for (let c = 0; c < 3; c++) {
                    if (grid[boxRow + r][boxCol + c] === num) return false;
                }
            }
            
            return true;
        }

        // Enhanced uniqueness checker
        function hasUniqueSolution() {
            // Clone the current board to avoid modifying it
            const tempBoard = JSON.parse(JSON.stringify(board));
            
            // Find the first solution
            const firstSolution = findOneSolution(tempBoard);
            if (!firstSolution) {
                return false; // No solution exists
            }
            
            // Try to find a second solution
            const hasSecondSolution = findSecondSolution(tempBoard, firstSolution);
            
            // Return true only if exactly one solution exists
            return !hasSecondSolution;
        }

        // Find one solution to the board
        function findOneSolution(grid) {
            // Create a copy of the grid to store the solution
            const solution = JSON.parse(JSON.stringify(grid));
            
            // Find an empty cell
            let emptyCell = findEmptyCell(solution);
            if (!emptyCell) {
                return solution; // Board is already solved
            }
            
            // Use backtracking to find a solution
            if (solveForOneSolution(solution)) {
                return solution;
            }
            
            return null; // No solution found
        }

        // Find a second different solution
        function findSecondSolution(grid, firstSolution) {
            // Create a copy of the grid to work with
            const workGrid = JSON.parse(JSON.stringify(grid));
            
            // Try to find a solution different from the first one
            return solveForSecondSolution(workGrid, firstSolution);
        }

        // Backtracking solver for first solution
        function solveForOneSolution(grid) {
            // Find an empty cell
            let emptyCell = findEmptyCell(grid);
            if (!emptyCell) {
                return true; // No empty cells, puzzle is solved
            }
            
            const { row, col } = emptyCell;
            
            // Try each number 1-9
            for (let num = 1; num <= 9; num++) {
                if (isValidPlace(grid, row, col, num)) {
                    // Place the number
                    grid[row][col] = num;
                    
                    // Recursively solve the rest of the puzzle
                    if (solveForOneSolution(grid)) {
                        return true;
                    }
                    
                    // If we get here, this placement didn't work
                    grid[row][col] = 0; // Backtrack
                }
            }
            
            return false; // No solution found with current grid
        }

        // Backtracking solver for second solution
        function solveForSecondSolution(grid, firstSolution) {
            // Find an empty cell
            let emptyCell = findEmptyCell(grid);
            if (!emptyCell) {
                // Check if this solution is different from the first one
                return isDifferentSolution(grid, firstSolution);
            }
            
            const { row, col } = emptyCell;
            
            // Try each number 1-9
            for (let num = 1; num <= 9; num++) {
                if (isValidPlace(grid, row, col, num)) {
                    // Place the number
                    grid[row][col] = num;
                    
                    // Recursively solve the rest of the puzzle
                    if (solveForSecondSolution(grid, firstSolution)) {
                        return true; // Found a second solution
                    }
                    
                    // If we get here, this placement didn't work
                    grid[row][col] = 0; // Backtrack
                }
            }
            
            return false; // No second solution found with current grid
        }

        // Find an empty cell in the grid
        function findEmptyCell(grid) {
            for (let row = 0; row < 9; row++) {
                for (let col = 0; col < 9; col++) {
                    if (grid[row][col] === 0) {
                        return { row, col };
                    }
                }
            }
            return null; // No empty cells
        }

        // Check if two solutions are different
        function isDifferentSolution(grid1, grid2) {
            for (let row = 0; row < 9; row++) {
                for (let col = 0; col < 9; col++) {
                    if (grid1[row][col] !== grid2[row][col]) {
                        return true; // Found a difference
                    }
                }
            }
            return false; // Solutions are identical
        }
        
        // Create a puzzle by removing cells from the solution
        function createPuzzle(difficulty) {
            // Start timing puzzle generation
            const startTime = performance.now();
            
            // Start with the full solution
            board = JSON.parse(JSON.stringify(solution));
            
            // Reset initial cells tracking
            initialCells = Array(9).fill().map(() => Array(9).fill(true));
            
            // Reset pencil marks
            pencilMarks = Array(9).fill().map(() => Array(9).fill().map(() => Array(9).fill(false)));
            
            // Reset correct cells
            correctCells = Array(9).fill().map(() => Array(9).fill(false));
            
            // Reset completed numbers
            completedNumbers = Array(10).fill(false);
            
            // Get all cell positions
            const positions = [];
            for (let row = 0; row < 9; row++) {
                for (let col = 0; col < 9; col++) {
                    positions.push({ row, col });
                }
            }
            
            // Shuffle positions for random removal order
            shuffleArray(positions);
            
            // Set minimum clues (hard difficulty)
            let minClues = 25;
            
            // Current clue count starts at 81 (full board)
            let currentClues = 81;
            
            // Show status that we're generating
            showStatus("Generating a challenging puzzle...", false);
            
            // Try to remove cells while maintaining a unique solution
            for (const { row, col } of positions) {
                // Stop if we've reached the minimum clue count
                if (currentClues <= minClues) {
                    break;
                }
                
                // Remember the current value
                const temp = board[row][col];
                
                // Try removing this cell
                board[row][col] = 0;
                initialCells[row][col] = false;
                currentClues--;
                
                // Check if the puzzle still has a unique solution
                if (!hasUniqueSolution()) {
                    // If not, restore the cell
                    board[row][col] = temp;
                    initialCells[row][col] = true;
                    currentClues++;
                }
            }
            
            // Store initial board for restart feature
            initialBoard = {
                board: JSON.parse(JSON.stringify(board)),
                initialCells: JSON.parse(JSON.stringify(initialCells))
            };
            
            // Reset current game hint tracking
            stats.currentGameUsedHint = false;
            
            // Calculate generation time
            puzzleGenerationTime = (performance.now() - startTime) / 1000;
            cluesCount = currentClues;
            
            console.log(`Generated puzzle with ${cluesCount} clues in ${puzzleGenerationTime.toFixed(2)} seconds`);
        }
        
        // Check if a number can be placed in a cell
        function isValidPlace(grid, row, col, num) {
            // Check row
            for (let x = 0; x < 9; x++) {
                if (grid[row][x] === num) return false;
            }
            
            // Check column
            for (let x = 0; x < 9; x++) {
                if (grid[x][col] === num) return false;
            }
            
            // Check 3x3 box
            const boxRow = Math.floor(row / 3) * 3;
            const boxCol = Math.floor(col / 3) * 3;
            
            for (let r = 0; r < 3; r++) {
                for (let c = 0; c < 3; c++) {
                    if (grid[boxRow + r][boxCol + c] === num) return false;
                }
            }
            
            return true;
        }
        
        // Show new game confirmation
        function showNewGameConfirmation() {
            document.getElementById('new-game-confirm-modal').style.display = 'flex';
        }
        
        // Start a new game
        function newGame() {
            // Reset hints
            hintsRemaining = 3;
            updateHintButton();
            
            // Show generating message 
            showStatus("Generating a unique puzzle...", false);
            
            // Use setTimeout to allow the UI to update before heavy computation
            setTimeout(() => {
                // Generate a new puzzle
                generateSolution();
                createPuzzle('hard');
                updateBoard();
                
                // Reset selected cell
                if (selectedCell) {
                    selectedCell.classList.remove('cell-selected', 'bg-gray-600');
                    selectedCell = null;
                }
                
                // Clear highlights
                clearHighlights();
                
                // Reset number highlight mode
                isNumberHighlightMode = false;
                highlightedNumber = null;
                
                // Show message with generation info
                showStatus("Think you got what it takes, Detective?", false);
                
                // Save game state
                saveCurrentGame();
            }, 50);
        }
        
        // Show hint confirmation
        function showHintConfirmation() {
            if (hintsRemaining <= 0) {
                showStatus("No more hints available. You're on your own now.", true);
                return;
            }
            
            // Find if there are any unfilled cells
            let hasEmptyCells = false;
            for (let row = 0; row < 9; row++) {
                for (let col = 0; col < 9; col++) {
                    if (board[row][col] === 0) {
                        hasEmptyCells = true;
                        break;
                    }
                }
                if (hasEmptyCells) break;
            }
            
            if (!hasEmptyCells) {
                showStatus("No empty cells to give hints for!", true);
                return;
            }
            
            // Update the hints remaining display in the modal
            document.getElementById('hints-remaining-display').textContent = hintsRemaining;
            
            // Show the hint confirmation modal
            document.getElementById('hint-confirm-modal').style.display = 'flex';
        }
        
        // Check the current solution
        function checkSolution() {
            let isFull = true;
            let isCorrect = true;
            
            for (let row = 0; row < 9; row++) {
                for (let col = 0; col < 9; col++) {
                    if (board[row][col] === 0) {
                        isFull = false;
                    } else if (board[row][col] !== solution[row][col]) {
                        isCorrect = false;
                    }
                }
            }
            
            if (!isFull) {
                showStatus("The puzzle isn't complete yet, keep investigating!", true);
            } else if (!isCorrect) {
                showStatus("There are mistakes in your solution. The Riddler laughs.", true);
            } else {
                showStatus("Case solved. The city is safe!", false);
                
                // Update statistics
                stats.puzzlesSolved++;
                if (!stats.currentGameUsedHint) {
                    stats.noHintSolves++;
                }
                
                // Update statistics display
                updateStatisticsDisplay();
                
                // Save statistics
                saveStats();
            }
        }
        
        // Get a hint
        function getHint() {
            if (hintsRemaining <= 0) {
                showStatus("No more hints available. You're on your own now.", true);
                return;
            }
            
            // Find an unfilled cell
            const emptyCells = [];
            for (let row = 0; row < 9; row++) {
                for (let col = 0; col < 9; col++) {
                    if (board[row][col] === 0) {
                        emptyCells.push({ row, col });
                    }
                }
            }
            
            if (emptyCells.length === 0) {
                showStatus("No empty cells to give hints for!", true);
                return;
            }
            
            // Choose a random empty cell
            const cell = emptyCells[Math.floor(Math.random() * emptyCells.length)];
            
            // Fill in the correct value
            board[cell.row][cell.col] = solution[cell.row][cell.col];
            initialCells[cell.row][cell.col] = true;
            
            // Clear pencil marks for this cell
            pencilMarks[cell.row][cell.col] = Array(9).fill(false);
            
            // Update the board
            updateBoard();
            
            // Reduce hints
            hintsRemaining--;
            updateHintButton();
            
            // Mark that a hint was used in this game
            stats.currentGameUsedHint = true;
            
            showStatus("Oracle has provided intel. Hints remaining: " + hintsRemaining, false);
            
            // Save game state
            saveCurrentGame();
        }
        
        // Toggle pencil mark for a cell
        function togglePencilMark(row, col, num) {
            pencilMarks[row][col][num-1] = !pencilMarks[row][col][num-1];
            updateBoard();
            saveCurrentGame();
        }
        
        // Set a cell's value (normal mode)
        function setCellValue(row, col, value) {
            // Check if cell is correct and should be locked
            if (correctCells[row][col]) {
                showStatus("This cell is correct and locked! Try another cell.", true);
                return;
            }
            
            // Clear pencil marks when setting a value
            pencilMarks[row][col] = Array(9).fill(false);
            
            // Set the cell value
            board[row][col] = value;
            
            // Auto-remove related pencil marks with the same number
            clearRelatedPencilMarks(row, col, value);
            
            updateBoard();
            saveCurrentGame();
        }
        
        // Clear related pencil marks with the same number
        function clearRelatedPencilMarks(row, col, value) {
            const valueIndex = value - 1;
            
            // Clear row pencil marks
            for (let c = 0; c < 9; c++) {
                if (c !== col && board[row][c] === 0) {
                    pencilMarks[row][c][valueIndex] = false;
                }
            }
            
            // Check column pencil marks
            for (let r = 0; r < 9; r++) {
                if (r !== row && board[r][col] === 0) {
                    pencilMarks[r][col][valueIndex] = false;
                }
            }
            
            // Clear box pencil marks
            const boxRowStart = Math.floor(row / 3) * 3;
            const boxColStart = Math.floor(col / 3) * 3;
            
            for (let r = boxRowStart; r < boxRowStart + 3; r++) {
                for (let c = boxColStart; c < boxColStart + 3; c++) {
                    if ((r !== row || c !== col) && board[r][c] === 0) {
                        pencilMarks[r][c][valueIndex] = false;
                    }
                }
            }
        }
        
        // Update the hint button text
        function updateHintButton() {
            const hintBtn = document.getElementById('hint-btn');
            hintBtn.textContent = `HINT (${hintsRemaining})`;
        }
        
        // Update the mode buttons
        function updateModeButtons() {
            const normalModeBtn = document.getElementById('normal-mode-btn');
            const pencilModeBtn = document.getElementById('pencil-mode-btn');
            
            if (isPencilMode) {
                normalModeBtn.classList.remove('bg-batman-yellow', 'text-batman-black');
                normalModeBtn.classList.add('bg-gray-600', 'text-gray-300');
                
                pencilModeBtn.classList.remove('text-gray-300');
                pencilModeBtn.classList.add('bg-batman-yellow', 'text-batman-black');
            } else {
                normalModeBtn.classList.remove('bg-gray-600', 'text-gray-300');
                normalModeBtn.classList.add('bg-batman-yellow', 'text-batman-black');
                
                pencilModeBtn.classList.remove('bg-batman-yellow', 'text-batman-black');
                pencilModeBtn.classList.add('text-gray-300');
            }
        }
        
        // Update statistics display
        function updateStatisticsDisplay() {
            document.getElementById('puzzles-solved').textContent = stats.puzzlesSolved;
            document.getElementById('no-hint-solves').textContent = stats.noHintSolves;
            
            // Update player name field
            const playerNameInput = document.getElementById('player-name');
            playerNameInput.value = stats.playerName || 'Detective';
        }
        
        // Show a status message
        function showStatus(message, isError) {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            
            if (isError) {
                statusEl.classList.remove('text-batman-yellow');
                statusEl.classList.add('text-red-400');
            } else {
                statusEl.classList.remove('text-red-400');
                statusEl.classList.add('text-batman-yellow');
            }
            
            // Reset after delay
            setTimeout(() => {
                statusEl.classList.remove('text-red-400');
                statusEl.classList.add('text-batman-yellow');
                statusEl.textContent = "Solve the puzzle, save the city.";
            }, 3000);
        }
        
        // Shuffle array in-place
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }
        
        // Save current game state to localStorage
        function saveCurrentGame() {
            // Only save if auto-save is enabled
            if (!autoSaveEnabled) return;
            
            // Current game state
            const currentGame = {
                board: board,
                initialCells: initialCells,
                solution: solution,
                hintsRemaining: hintsRemaining,
                pencilMarks: pencilMarks,
                correctCells: correctCells,
                initialBoard: initialBoard,
                timestamp: new Date().toISOString(),
                gridScale: gridScale,
                completedNumbers: completedNumbers // Save completed numbers state
            };
            
            try {
                localStorage.setItem('currentGame', JSON.stringify(currentGame));
                
                // Show save notification (for manual saves)
                if (!autoSaveInterval) {
                    showSaveNotification('Game saved');
                }
            } catch (e) {
                console.error('Failed to save game:', e);
            }
        }
        
        // Load current game state from localStorage
        function loadCurrentGame() {
            try {
                const savedGame = localStorage.getItem('currentGame');
                if (savedGame) {
                    const gameData = JSON.parse(savedGame);
                    
                    // Load game state
                    board = gameData.board;
                    initialCells = gameData.initialCells;
                    solution = gameData.solution;
                    hintsRemaining = gameData.hintsRemaining;
                    
                    // Handle pencil marks
                    if (gameData.pencilMarks) {
                        pencilMarks = gameData.pencilMarks;
                    }
                    
                    // Handle correct cells
                    if (gameData.correctCells) {
                        correctCells = gameData.correctCells;
                    } else {
                        correctCells = Array(9).fill().map(() => Array(9).fill(false));
                    }
                    
                    // Handle initial board for restart
                    if (gameData.initialBoard) {
                        initialBoard = gameData.initialBoard;
                    }
                    
                    // Handle completed numbers
                    if (gameData.completedNumbers) {
                        completedNumbers = gameData.completedNumbers;
                    } else {
                        completedNumbers = Array(10).fill(false);
                    }
                    
                    // Handle grid scale
                    if (gameData.gridScale) {
                        setGridScale(gameData.gridScale);
                    }
                    
                    // Update UI
                    updateBoard();
                    updateHintButton();
                    
                    return true;
                }
            } catch (e) {
                console.error('Failed to load game:', e);
            }
            
            return false;
        }
        
        // Save game with name
        function saveNamedGame(name) {
            const gameName = name || `Game ${new Date().toLocaleString()}`;
            
            // Prepare game state
            const gameState = {
                name: gameName,
                board: board,
                initialCells: initialCells,
                solution: solution,
                hintsRemaining: hintsRemaining,
                pencilMarks: pencilMarks,
                correctCells: correctCells,
                initialBoard: initialBoard,
                timestamp: new Date().toISOString(),
                gridScale: gridScale,
                completedNumbers: completedNumbers
            };
            
            try {
                // Get existing saved games
                let savedGames = [];
                const savedGamesData = localStorage.getItem('savedGames');
                
                if (savedGamesData) {
                    savedGames = JSON.parse(savedGamesData);
                }
                
                // Add new game
                savedGames.push(gameState);
                
                // Save back to localStorage
                localStorage.setItem('savedGames', JSON.stringify(savedGames));
                
                // Show notification
                showSaveNotification('Game saved as: ' + gameName);
                
                // Update saved games list
                updateSavedGamesList();
                
                return true;
            } catch (e) {
                console.error('Failed to save named game:', e);
                return false;
            }
        }
        
        // Load a saved game
        function loadSavedGame(index) {
            try {
                const savedGamesData = localStorage.getItem('savedGames');
                
                if (savedGamesData) {
                    const savedGames = JSON.parse(savedGamesData);
                    
                    if (savedGames[index]) {
                        const gameData = savedGames[index];
                        
                        // Load game state
                        board = gameData.board;
                        initialCells = gameData.initialCells;
                        solution = gameData.solution;
                        hintsRemaining = gameData.hintsRemaining;
                        pencilMarks = gameData.pencilMarks || Array(9).fill().map(() => Array(9).fill().map(() => Array(9).fill(false)));
                        
                        // Handle correct cells
                        correctCells = gameData.correctCells || Array(9).fill().map(() => Array(9).fill(false));
                        
                        // Handle initial board for restart
                        initialBoard = gameData.initialBoard;
                        
                        // Handle completed numbers
                        completedNumbers = gameData.completedNumbers || Array(10).fill(false);
                        
                        // Handle grid scale
                        if (gameData.gridScale) {
                            setGridScale(gameData.gridScale);
                        }
                        
                        // Update UI
                        updateBoard();
                        updateHintButton();
                        
                        // Close modal
                        document.getElementById('saved-games-modal').style.display = 'none';
                        
                        // Show message
                        showStatus(`Loaded game: ${gameData.name}`, false);
                        
                        // Save as current game
                        saveCurrentGame();
                        
                        return true;
                    }
                }
            } catch (e) {
                console.error('Failed to load saved game:', e);
            }
            
            return false;
        }
        
        // Delete a saved game
        function deleteSavedGame(index) {
            try {
                const savedGamesData = localStorage.getItem('savedGames');
                
                if (savedGamesData) {
                    const savedGames = JSON.parse(savedGamesData);
                    
                    if (savedGames[index]) {
                        // Remove the game
                        savedGames.splice(index, 1);
                        
                        // Save back to localStorage
                        localStorage.setItem('savedGames', JSON.stringify(savedGames));
                        
                        // Update UI
                        updateSavedGamesList();
                        
                        return true;
                    }
                }
            } catch (e) {
                console.error('Failed to delete saved game:', e);
            }
            
            return false;
        }
        
        // Update saved games list in the modal
        function updateSavedGamesList() {
            const container = document.getElementById('saved-games-container');
            const noSavedGamesMsg = document.getElementById('no-saved-games');
            
            // Clear container
            container.innerHTML = '';
            
            try {
                const savedGamesData = localStorage.getItem('savedGames');
                
                if (savedGamesData) {
                    const savedGames = JSON.parse(savedGamesData);
                    
                    if (savedGames.length > 0) {
                        noSavedGamesMsg.style.display = 'none';
                        
                        // Add each saved game
                        savedGames.forEach((game, index) => {
                            const gameItem = document.createElement('div');
                            gameItem.classList.add('bg-gray-700', 'p-3', 'rounded', 'flex', 'justify-between', 'items-center');
                            
                            const date = new Date(game.timestamp);
                            const dateFormatted = date.toLocaleDateString() + ' ' + date.toLocaleTimeString();
                            
                            const gameInfo = document.createElement('div');
                            gameInfo.innerHTML = `
                                <div class="font-bold text-white">${game.name}</div>
                                <div class="text-xs text-gray-400">${dateFormatted}</div>
                            `;
                            
                            const buttonsContainer = document.createElement('div');
                            buttonsContainer.classList.add('flex', 'gap-2');
                            
                            const loadBtn = document.createElement('button');
                            loadBtn.classList.add('bg-green-600', 'text-white', 'px-2', 'py-1', 'rounded', 'text-xs');
                            loadBtn.textContent = 'Load';
                            loadBtn.addEventListener('click', () => loadSavedGame(index));
                            
                            const deleteBtn = document.createElement('button');
                            deleteBtn.classList.add('bg-red-600', 'text-white', 'px-2', 'py-1', 'rounded', 'text-xs');
                            deleteBtn.textContent = 'Delete';
                            deleteBtn.addEventListener('click', () => {
                                if (confirm('Are you sure you want to delete this saved game?')) {
                                    deleteSavedGame(index);
                                }
                            });
                            
                            buttonsContainer.appendChild(loadBtn);
                            buttonsContainer.appendChild(deleteBtn);
                            
                            gameItem.appendChild(gameInfo);
                            gameItem.appendChild(buttonsContainer);
                            
                            container.appendChild(gameItem);
                        });
                    } else {
                        noSavedGamesMsg.style.display = 'block';
                    }
                } else {
                    noSavedGamesMsg.style.display = 'block';
                }
            } catch (e) {
                console.error('Failed to update saved games list:', e);
                noSavedGamesMsg.style.display = 'block';
            }
        }
        
        // Save statistics to localStorage
        function saveStats() {
            try {
                localStorage.setItem('sudokuStats', JSON.stringify(stats));
            } catch (e) {
                console.error('Failed to save statistics:', e);
            }
        }
        
        // Load statistics from localStorage
        function loadStats() {
            try {
                const savedStats = localStorage.getItem('sudokuStats');
                if (savedStats) {
                    const loadedStats = JSON.parse(savedStats);
                    
                    // Merge stats
                    stats = {
                        ...stats, // Default values
                        ...loadedStats // Loaded values
                    };
                    
                    updateStatisticsDisplay();
                    return true;
                }
            } catch (e) {
                console.error('Failed to load statistics:', e);
            }
            
            return false;
        }
        
        // Clear all stored data
        function clearAllData() {
            try {
                localStorage.removeItem('currentGame');
                localStorage.removeItem('savedGames');
                localStorage.removeItem('sudokuStats');
                localStorage.removeItem('sudokuSettings');
                
                showStatus('All data cleared successfully', false);
                
                // Reset stats
                stats = {
                    puzzlesSolved: 0,
                    noHintSolves: 0,
                    currentGameUsedHint: false,
                    playerName: 'Detective'
                };
                
                updateStatisticsDisplay();
                
                return true;
            } catch (e) {
                console.error('Failed to clear data:', e);
                return false;
            }
        }
        
        // Save settings
        function saveSettings() {
            try {
                const settings = {
                    autoSaveEnabled,
                    gridScale,
                    highlightRowColBox,
                    highlightSameNumbers
                };
                
                localStorage.setItem('sudokuSettings', JSON.stringify(settings));
            } catch (e) {
                console.error('Failed to save settings:', e);
            }
        }
        
        // Load settings
        function loadSettings() {
            try {
                const savedSettings = localStorage.getItem('sudokuSettings');
                if (savedSettings) {
                    const settings = JSON.parse(savedSettings);
                    
                    if (settings.autoSaveEnabled !== undefined) {
                        autoSaveEnabled = settings.autoSaveEnabled;
                        document.getElementById('auto-save-toggle').checked = autoSaveEnabled;
                    }
                    
                    if (settings.gridScale !== undefined) {
                        setGridScale(settings.gridScale);
                    }
                    
                    if (settings.highlightRowColBox !== undefined) {
                        highlightRowColBox = settings.highlightRowColBox;
                        document.getElementById('highlight-row-col-box').checked = highlightRowColBox;
                    }
                    
                    if (settings.highlightSameNumbers !== undefined) {
                        highlightSameNumbers = settings.highlightSameNumbers;
                        document.getElementById('highlight-same-numbers').checked = highlightSameNumbers;
                    }
                    
                    return true;
                }
            } catch (e) {
                console.error('Failed to load settings:', e);
            }
            
            return false;
        }
        
        // Start auto-save
        function startAutoSave() {
            if (autoSaveInterval) {
                clearInterval(autoSaveInterval);
            }
            
            if (autoSaveEnabled) {
                autoSaveInterval = setInterval(() => {
                    saveCurrentGame();
                    showSaveNotification('Game auto-saved');
                }, 30000); // 30 seconds
            }
        }
        
        // Stop auto-save
        function stopAutoSave() {
            if (autoSaveInterval) {
                clearInterval(autoSaveInterval);
                autoSaveInterval = null;
            }
        }
        
        // Show save notification
        function showSaveNotification(message) {
            const notification = document.getElementById('save-notification');
            notification.textContent = message;
            notification.style.display = 'block';
            
            setTimeout(() => {
                notification.style.display = 'none';
            }, 2000);
        }
        
        // Set grid scale
        function setGridScale(scale) {
            // Limit scale between 60% and 150%
            gridScale = Math.max(60, Math.min(150, scale));
            
            // Update board
            const board = document.getElementById('sudoku-board');
            board.style.transform = `scale(${gridScale / 100})`;
            
            // Add margin to account for scaling
            const scaleAdjustment = (gridScale - 100) / 2;
            board.style.margin = `${scaleAdjustment}px ${scaleAdjustment}px`;
            
            // Update display
            document.getElementById('grid-size-display').textContent = `${gridScale}%`;
            
            // Save settings
            saveSettings();
        }
        
        // Encode the current puzzle to base64
        function encodePuzzle() {
            const puzzleData = {
                board: board,
                initialCells: initialCells,
                solution: solution,
                hintsRemaining: hintsRemaining,
                pencilMarks: pencilMarks,
                correctCells: correctCells,
                initialBoard: initialBoard,
                completedNumbers: completedNumbers,
                stats: stats
            };
            
            return btoa(JSON.stringify(puzzleData));
        }
        
        // Decode a puzzle from base64
        function decodePuzzle(encoded) {
            try {
                const puzzleData = JSON.parse(atob(encoded));
                
                // Validate data
                if (!puzzleData.board || !puzzleData.initialCells || !puzzleData.solution || 
                    puzzleData.hintsRemaining === undefined) {
                    return false;
                }
                
                // Set the game state
                board = puzzleData.board;
                initialCells = puzzleData.initialCells;
                solution = puzzleData.solution;
                hintsRemaining = puzzleData.hintsRemaining;
                
                // Handle pencil marks (optional in older saves)
                if (puzzleData.pencilMarks) {
                    pencilMarks = puzzleData.pencilMarks;
                } else {
                    pencilMarks = Array(9).fill().map(() => Array(9).fill().map(() => Array(9).fill(false)));
                }
                
                // Handle correct cells (optional in older saves)
                if (puzzleData.correctCells) {
                    correctCells = puzzleData.correctCells;
                } else {
                    correctCells = Array(9).fill().map(() => Array(9).fill(false));
                }
                
                // Handle initial board for restart (optional in older saves)
                if (puzzleData.initialBoard) {
                    initialBoard = puzzleData.initialBoard;
                }
                
                // Handle completed numbers (optional in older saves)
                if (puzzleData.completedNumbers) {
                    completedNumbers = puzzleData.completedNumbers;
                } else {
                    completedNumbers = Array(10).fill(false);
                }
                
                // Handle stats (optional in older saves)
                if (puzzleData.stats) {
                    stats = puzzleData.stats;
                    updateStatisticsDisplay();
                }
                
                // Update the UI
                updateBoard();
                updateHintButton();
                
                // Reset selected cell
                if (selectedCell) {
                    selectedCell.classList.remove('cell-selected', 'bg-gray-600');
                    selectedCell = null;
                }
                
                // Clear highlights
                clearHighlights();
                
                // Reset number highlight mode
                isNumberHighlightMode = false;
                highlightedNumber = null;
                
                // Save imported game
                saveCurrentGame();
                
                return true;
            } catch (e) {
                console.error("Error decoding puzzle:", e);
                return false;
            }
        }
        
        // Share the current puzzle
        function sharePuzzle() {
            // Generate encoded puzzle
            const encodedPuzzle = encodePuzzle();
            
            // Set share code
            const shareCodeInput = document.getElementById('share-code');
            shareCodeInput.value = encodedPuzzle;
            
            // Show the share modal
            document.getElementById('share-modal').style.display = 'flex';
        }
        
        // Import a puzzle
        function importPuzzle() {
            // Show the import modal
            document.getElementById('import-modal').style.display = 'flex';
        }
        
        // Copy the puzzle code to clipboard
        function copyToClipboard() {
            const shareCodeInput = document.getElementById('share-code');
            shareCodeInput.select();
            document.execCommand('copy');
            
            // Show copied message
            const copyMessage = document.getElementById('copy-message');
            copyMessage.classList.remove('hidden');
            
            // Hide the message after 2 seconds
            setTimeout(() => {
                copyMessage.classList.add('hidden');
            }, 2000);
        }
        
        // Submit imported puzzle
        function submitImportedPuzzle() {
            const importCode = document.getElementById('import-code').value;
            const importError = document.getElementById('import-error');
            
            if (importCode.trim() === '') {
                importError.textContent = "Please enter a puzzle code.";
                importError.classList.remove('hidden');
                return;
            }
            
            const success = decodePuzzle(importCode);
            
            if (success) {
                // Close the modal and show success message
                document.getElementById('import-modal').style.display = 'none';
                showStatus("Puzzle imported successfully.", false);
                
                // Save as current game
                saveCurrentGame();
            } else {
                // Show error message
                importError.textContent = "Invalid puzzle code. Please try again.";
                importError.classList.remove('hidden');
            }
        }
        
        // Show statistics
        function showStatistics() {
            updateStatisticsDisplay();
            document.getElementById('stats-modal').style.display = 'flex';
        }
        
        // Show settings modal
        function showSettings() {
            // Update UI to match current settings
            document.getElementById('auto-save-toggle').checked = autoSaveEnabled;
            document.getElementById('highlight-row-col-box').checked = highlightRowColBox;
            document.getElementById('highlight-same-numbers').checked = highlightSameNumbers;
            
            // Show modal
            document.getElementById('settings-modal').style.display = 'flex';
        }
        
        // Show saved games modal
        function showSavedGames() {
            updateSavedGamesList();
            document.getElementById('saved-games-modal').style.display = 'flex';
        }
        
        // Set up event listeners
        function setupEventListeners() {
            // Number buttons
            document.querySelectorAll('.number-btn').forEach(button => {
                button.addEventListener('click', function(e) {
                    const num = parseInt(this.dataset.num);
                    
                    // Check if this number is completed
                    if (completedNumbers[num]) {
                        showStatus(`All ${num}'s are already correctly placed!`, false);
                        return;
                    }
                    
                    // Handle number highlighting mode
                    if (!selectedCell || isNumberHighlightMode) {
                        // If the same number is clicked again, exit highlight mode
                        if (isNumberHighlightMode && highlightedNumber === num) {
                            clearAllHighlights();
                            isNumberHighlightMode = false;
                            highlightedNumber = null;
                        } else {
                            // Enter highlight mode for this number
                            highlightPlacementOptions(num);
                            isNumberHighlightMode = true;
                            highlightedNumber = num;
                        }
                        return;
                    }
                    
                    const row = parseInt(selectedCell.dataset.row);
                    const col = parseInt(selectedCell.dataset.col);
                    
                    if (initialCells[row][col]) {
                        showStatus("Can't change initial clues!", true);
                        return;
                    }
                    
                    // Check if cell is correct and should be locked
                    if (correctCells[row][col]) {
                        showStatus("This cell is correct and locked! Try another cell.", true);
                        return;
                    }
                    
                    if (isPencilMode) {
                        // Toggle pencil mark for this number
                        togglePencilMark(row, col, num);
                    } else {
                        // Set the cell value
                        setCellValue(row, col, num);
                    }
                });
            });
            
            // Erase button
            document.getElementById('erase-btn').addEventListener('click', () => {
                // Exit number highlight mode
                if (isNumberHighlightMode) {
                    clearAllHighlights();
                    isNumberHighlightMode = false;
                    highlightedNumber = null;
                    return;
                }
                
                if (!selectedCell) {
                    showStatus("Select a cell first, Detective.", true);
                    return;
                }
                
                const row = parseInt(selectedCell.dataset.row);
                const col = parseInt(selectedCell.dataset.col);
                
                if (initialCells[row][col]) {
                    showStatus("Can't change initial clues!", true);
                    return;
                }
                
                // Check if cell is correct and should be locked
                if (correctCells[row][col]) {
                    showStatus("This cell is correct and locked! Try another cell.", true);
                    return;
                }
                
                if (isPencilMode) {
                    // Clear all pencil marks for this cell
                    pencilMarks[row][col] = Array(9).fill(false);
                } else {
                    // Clear the cell value
                    board[row][col] = 0;
                }
                
                updateBoard();
                saveCurrentGame();
            });
            
            // Mode toggle buttons
            document.getElementById('normal-mode-btn').addEventListener('click', () => {
                isPencilMode = false;
                updateModeButtons();
            });
            
            document.getElementById('pencil-mode-btn').addEventListener('click', () => {
                isPencilMode = true;
                updateModeButtons();
            });
            
            // Highlight toggle checkboxes (moved to settings)
            document.getElementById('highlight-row-col-box').addEventListener('change', (e) => {
                highlightRowColBox = e.target.checked;
                if (selectedCell) {
                    clearHighlights();
                    const row = parseInt(selectedCell.dataset.row);
                    const col = parseInt(selectedCell.dataset.col);
                    
                    if (highlightRowColBox) {
                        highlightRelatedCells(row, col);
                    }
                    
                    if (highlightSameNumbers && board[row][col] !== 0) {
                        highlightSameNumber(board[row][col]);
                    }
                }
                saveSettings();
            });
            
            document.getElementById('highlight-same-numbers').addEventListener('change', (e) => {
                highlightSameNumbers = e.target.checked;
                if (selectedCell) {
                    clearHighlights();
                    const row = parseInt(selectedCell.dataset.row);
                    const col = parseInt(selectedCell.dataset.col);
                    
                    if (highlightRowColBox) {
                        highlightRelatedCells(row, col);
                    }
                    
                    if (highlightSameNumbers && board[row][col] !== 0) {
                        highlightSameNumber(board[row][col]);
                    }
                }
                saveSettings();
            });
            
            // New game button - Show confirmation instead of starting new game immediately
            document.getElementById('new-game-btn').addEventListener('click', showNewGameConfirmation);
            
            // New game confirmation buttons
            document.getElementById('confirm-new-game-btn').addEventListener('click', () => {
                document.getElementById('new-game-confirm-modal').style.display = 'none';
                newGame();
            });
            
            document.getElementById('cancel-new-game-btn').addEventListener('click', () => {
                document.getElementById('new-game-confirm-modal').style.display = 'none';
            });
            
            document.getElementById('close-new-game-modal').addEventListener('click', () => {
                document.getElementById('new-game-confirm-modal').style.display = 'none';
            });
            
            // Check button
            document.getElementById('check-btn').addEventListener('click', checkSolution);
            
            // Hint button - Show confirmation instead of using hint immediately
            document.getElementById('hint-btn').addEventListener('click', showHintConfirmation);
            
            // Hint confirmation buttons
            document.getElementById('confirm-hint-btn').addEventListener('click', () => {
                document.getElementById('hint-confirm-modal').style.display = 'none';
                getHint();
            });
            
            document.getElementById('cancel-hint-btn').addEventListener('click', () => {
                document.getElementById('hint-confirm-modal').style.display = 'none';
            });
            
            document.getElementById('close-hint-modal').addEventListener('click', () => {
                document.getElementById('hint-confirm-modal').style.display = 'none';
            });
            
            // Share button
            document.getElementById('share-btn').addEventListener('click', sharePuzzle);
            
            // Copy button
            document.getElementById('copy-btn').addEventListener('click', copyToClipboard);
            
            // Statistics button
            document.getElementById('stats-btn').addEventListener('click', showStatistics);
            
            // Settings button
            document.getElementById('settings-btn').addEventListener('click', showSettings);
            
            // Saved games button - FIX: Ensure this event handler works reliably
            const savedGamesBtn = document.getElementById('saved-games-btn');
            
            // Remove any existing event listeners (just in case)
            const newSavedGamesBtn = savedGamesBtn.cloneNode(true);
            savedGamesBtn.parentNode.replaceChild(newSavedGamesBtn, savedGamesBtn);
            
            // Add event listener with the click event
            newSavedGamesBtn.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                showSavedGames();
            });
            
            // Close share modal
            document.getElementById('close-share-modal').addEventListener('click', () => {
                document.getElementById('share-modal').style.display = 'none';
            });
            
            // Close import modal
            document.getElementById('close-import-modal').addEventListener('click', () => {
                document.getElementById('import-modal').style.display = 'none';
                document.getElementById('import-error').classList.add('hidden');
            });
            
            // Close stats modal
            document.getElementById('close-stats-modal').addEventListener('click', () => {
                document.getElementById('stats-modal').style.display = 'none';
            });
            
            // Save stats button
            document.getElementById('save-stats-btn').addEventListener('click', () => {
                // Update player name
                stats.playerName = document.getElementById('player-name').value || 'Detective';
                
                // Save stats
                saveStats();
                
                // Close modal
                document.getElementById('stats-modal').style.display = 'none';
                
                // Show confirmation
                showStatus('Detective profile updated', false);
            });
            
            // Close settings modal
            document.getElementById('close-settings-modal').addEventListener('click', () => {
                document.getElementById('settings-modal').style.display = 'none';
            });
            
            // Auto-save toggle
            document.getElementById('auto-save-toggle').addEventListener('change', (e) => {
                autoSaveEnabled = e.target.checked;
                
                if (autoSaveEnabled) {
                    startAutoSave();
                } else {
                    stopAutoSave();
                }
                
                saveSettings();
            });
            
            // Manual save button
            document.getElementById('manual-save-btn').addEventListener('click', () => {
                saveCurrentGame();
                showStatus('Game saved manually', false);
            });
            
            // Export game button
            document.getElementById('export-game-btn').addEventListener('click', () => {
                sharePuzzle();
                document.getElementById('settings-modal').style.display = 'none';
            });
            
            // Import game button
            document.getElementById('import-game-btn').addEventListener('click', () => {
                importPuzzle();
                document.getElementById('settings-modal').style.display = 'none';
            });
            
            // Clear data button
            document.getElementById('clear-data-btn').addEventListener('click', () => {
                if (confirm('Are you sure you want to delete all saved games and statistics? This cannot be undone.')) {
                    clearAllData();
                    document.getElementById('settings-modal').style.display = 'none';
                }
            });
            
            // Close saved games modal
            document.getElementById('close-saved-games-modal').addEventListener('click', () => {
                document.getElementById('saved-games-modal').style.display = 'none';
            });
            
            // Save game button - FIX: Ensure this event handler works reliably
            const saveGameBtn = document.getElementById('save-game-btn');
            
            // Remove any existing event listeners
            const newSaveGameBtn = saveGameBtn.cloneNode(true);
            saveGameBtn.parentNode.replaceChild(newSaveGameBtn, saveGameBtn);
            
            // Add event listener with the click event
            newSaveGameBtn.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                const gameName = document.getElementById('save-game-name').value || `Game ${new Date().toLocaleString()}`;
                saveNamedGame(gameName);
                updateSavedGamesList();
            });
            
            // Import submit button
            document.getElementById('import-submit-btn').addEventListener('click', submitImportedPuzzle);
            
            // Zoom controls
            document.getElementById('zoom-in').addEventListener('click', () => {
                setGridScale(gridScale + 10);
            });
            
            document.getElementById('zoom-out').addEventListener('click', () => {
                setGridScale(gridScale - 10);
            });
            
            // Close modals when clicking outside
            window.addEventListener('click', (e) => {
                const shareModal = document.getElementById('share-modal');
                const importModal = document.getElementById('import-modal');
                const statsModal = document.getElementById('stats-modal');
                const settingsModal = document.getElementById('settings-modal');
                const savedGamesModal = document.getElementById('saved-games-modal');
                const newGameModal = document.getElementById('new-game-confirm-modal');
                const hintModal = document.getElementById('hint-confirm-modal');
                
                if (e.target === shareModal) {
                    shareModal.style.display = 'none';
                }
                
                if (e.target === importModal) {
                    importModal.style.display = 'none';
                    document.getElementById('import-error').classList.add('hidden');
                }
                
                if (e.target === statsModal) {
                    statsModal.style.display = 'none';
                }
                
                if (e.target === settingsModal) {
                    settingsModal.style.display = 'none';
                }
                
                if (e.target === savedGamesModal) {
                    savedGamesModal.style.display = 'none';
                }
                
                if (e.target === newGameModal) {
                    newGameModal.style.display = 'none';
                }
                
                if (e.target === hintModal) {
                    hintModal.style.display = 'none';
                }
            });
            
            // Click on board to exit number highlight mode
            document.getElementById('sudoku-board').addEventListener('click', () => {
                if (isNumberHighlightMode) {
                    clearAllHighlights();
                    isNumberHighlightMode = false;
                    highlightedNumber = null;
                }
            });
            
            // Keyboard controls
            document.addEventListener('keydown', e => {
                // Exit number highlight mode with Escape key
                if (e.key === 'Escape' && isNumberHighlightMode) {
                    clearAllHighlights();
                    isNumberHighlightMode = false;
                    highlightedNumber = null;
                    return;
                }
                
                if (!selectedCell) return;
                
                const row = parseInt(selectedCell.dataset.row);
                const col = parseInt(selectedCell.dataset.col);
                
                if (initialCells[row][col]) return;
                
                // Check if cell is correct and locked
                if (correctCells[row][col] && !isPencilMode) return;
                
                if (e.key >= '1' && e.key <= '9') {
                    const num = parseInt(e.key);
                    
                    // Skip if number is completed
                    if (completedNumbers[num] && !isPencilMode) {
                        showStatus(`All ${num}'s are already correctly placed!`, false);
                        return;
                    }
                    
                    if (isPencilMode) {
                        togglePencilMark(row, col, num);
                    } else {
                        setCellValue(row, col, num);
                    }
                } else if (e.key === 'Backspace' || e.key === 'Delete') {
                    if (isPencilMode) {
                        pencilMarks[row][col] = Array(9).fill(false);
                    } else if (!correctCells[row][col]) {
                        // Only delete if not a correct cell
                        board[row][col] = 0;
                    }
                    updateBoard();
                    saveCurrentGame();
                } else if (e.key === '+' || e.key === '=') {
                    // Zoom in
                    setGridScale(gridScale + 10);
                } else if (e.key === '-' || e.key === '_') {
                    // Zoom out
                    setGridScale(gridScale - 10);
                }
            });
        }
        
        // Initialize and start the game
        function init() {
            initializeBoard();
            setupEventListeners();
            updateHintButton();
            updateModeButtons();
            
            // Load saved settings
            loadSettings();
            
            // Load saved statistics
            loadStats();
            
            // Try to load current game, if that fails, start a new game
            if (!loadCurrentGame()) {
                newGame();
            }
            
            // Start auto-save if enabled
            if (autoSaveEnabled) {
                startAutoSave();
            }
        }
        
        // Start game once DOM is loaded
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
